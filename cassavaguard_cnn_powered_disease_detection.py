# -*- coding: utf-8 -*-
"""cassavaguard-cnn-powered-disease-detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19zg0E7OkLAGoCO4aNCEgrbzJo2F0pAyw
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Define the path to the dataset
dataset_path = "/kaggle/input/cassava-leaf-disease-classification/data"

# Create an ImageDataGenerator for data augmentation
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2  # 80% for training, 20% for validation
)

# Load the training dataset
train_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),  # Adjust based on your model requirements
    batch_size=32,
    class_mode='categorical',  # Assuming a multi-class classification task
    subset='training'
)

# Load the validation dataset
validation_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)

"""**How to build a Convolutional Neural Network (CNN) for Cassava Leaf Disease classification?**"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# Build the CNN model
model = Sequential()

model.add(Conv2D(32, (3, 3), input_shape=(224, 224, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())

model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(5, activation='softmax'))  # 5 classes for Cassava leaf diseases

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

"""**How to train the Convolutional Neural Network on the Cassava Leaf Disease dataset?**"""

# Train the model
history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // validation_generator.batch_size,
    epochs=10  # Adjust the number of epochs based on your training requirements
)

"""**How to evaluate the trained Convolutional Neural Network?**"""

# Evaluate the model on the test set
test_loss, test_accuracy = model.evaluate(validation_generator)
print(f'Test Accuracy: {test_accuracy * 100:.2f}%')

"""**How to use computer vision to visualize the predictions and differences between disease patterns?**"""

import matplotlib.pyplot as plt
import numpy as np

# Get a batch of images and their true labels from the validation set
images, labels = validation_generator.next()

# Predict the labels for the batch
predictions = model.predict(images)

# Convert one-hot encoded labels to class indices
true_labels = np.argmax(labels, axis=1)
predicted_labels = np.argmax(predictions, axis=1)

# Visualize the images along with their true and predicted labels
plt.figure(figsize=(12, 8))
for i in range(len(images)):
    plt.subplot(4, 8, i + 1)
    plt.imshow(images[i])
    plt.title(f'True: {true_labels[i]}\nPredicted: {predicted_labels[i]}')
    plt.axis('off')

plt.show()

"""**How to visualize the training and validation loss and accuracy during training?**"""

# Plot the training history
plt.figure(figsize=(12, 4))

# Plot training & validation accuracy values
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Validation'], loc='upper left')

# Plot training & validation loss values
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Train', 'Validation'], loc='upper left')

plt.show()

"""**How to make predictions on new images using the trained Convolutional Neural Network?**"""

from tensorflow.keras.preprocessing import image
import numpy as np

def predict_image(model, img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0) / 255.0

    prediction = model.predict(img_array)
    predicted_class = np.argmax(prediction)

    return predicted_class, prediction

# Example usage
image_path = "/kaggle/input/leaf-image/46.jpg"
predicted_class, prediction = predict_image(model, image_path)

print(f"Predicted Class: {predicted_class}")
print(f"Class Probabilities: {prediction}")

"""**How to fine-tune the Convolutional Neural Network for better performance?**"""

from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.optimizers import Adam

# Load pre-trained MobileNetV2 model
base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze the base model layers
for layer in base_model.layers:
    layer.trainable = False

# Build a new model on top of the pre-trained base model
model = Sequential()
model.add(base_model)
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(5, activation='softmax'))

# Compile the model
model.compile(optimizer=Adam(lr=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
history_fine_tune = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // validation_generator.batch_size,
    epochs=5  # Fine-tune for a few epochs
)

"""**How to implement data augmentation to improve model generalization?**"""

# Define an augmented ImageDataGenerator for training data
train_datagen_augmented = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Load the augmented training dataset
train_generator_augmented = train_datagen_augmented.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

# Train the model with augmented data
history_augmented = model.fit(
    train_generator_augmented,
    steps_per_epoch=train_generator_augmented.samples // train_generator_augmented.batch_size,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // validation_generator.batch_size,
    epochs=10
)

"""**How to perform model evaluation using confusion matrix and classification report?**"""

from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns

# Generate predictions for the validation set
predictions = model.predict(validation_generator)
predicted_labels = np.argmax(predictions, axis=1)

# Get true labels
true_labels = validation_generator.classes

# Calculate confusion matrix
conf_matrix = confusion_matrix(true_labels, predicted_labels)

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=train_generator.class_indices, yticklabels=train_generator.class_indices)
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('True')
plt.show()

# Print classification report
class_labels = list(train_generator.class_indices.keys())
print("Classification Report:\n", classification_report(true_labels, predicted_labels, target_names=class_labels, zero_division=1))

"""**How to implement learning rate scheduling during training?**"""

from tensorflow.keras.callbacks import LearningRateScheduler

# Define a learning rate schedule function
def learning_rate_schedule(epoch):
    initial_lr = 0.001
    drop = 0.5
    epochs_drop = 5
    lr = initial_lr * (drop ** (epoch // epochs_drop))
    return lr

# Create a LearningRateScheduler callback
lr_scheduler = LearningRateScheduler(learning_rate_schedule)

# Train the model with learning rate scheduling
history_lr_schedule = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // train_generator.batch_size,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // validation_generator.batch_size,
    epochs=15,
    callbacks=[lr_scheduler]
)

"""**How to visualize differences and patterns in images?**"""

import os
# Load a few sample images from each class
sample_images = []
class_names = list(train_generator.class_indices.keys())

for class_name in class_names:
    class_path = os.path.join(dataset_path, class_name)
    image_path = os.path.join(class_path, os.listdir(class_path)[0])
    sample_images.append(image.load_img(image_path, target_size=(224, 224)))

# Display sample images
plt.figure(figsize=(12, 8))
for i, img in enumerate(sample_images):
    plt.subplot(2, 3, i+1)
    plt.imshow(img)
    plt.title(class_names[i])
    plt.axis('off')

plt.show()

"""**How to perform basic computer vision analysis using bounding boxes?**"""

import cv2
from tensorflow.keras.preprocessing import image

# Load an image for analysis
image_path = "/kaggle/input/cassava-leaf-disease-classification/data/Cassava___brown_streak_disease/1000723321.jpg"  # Replace with the path to your image
img = image.load_img(image_path, target_size=(224, 224))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0) / 255.0

# Perform object detection using a pre-trained model (e.g., YOLO)
# Replace this section with the appropriate code based on your chosen object detection method

# Display the original image
plt.figure(figsize=(6, 6))
plt.imshow(img)
plt.title('Original Image')
plt.axis('off')

# Display the image with bounding boxes (replace with detected bounding boxes)
# Example: Draw a rectangle around the center of the image
cv2.rectangle(img_array[0], (75, 75), (150, 150), (255, 0, 0), 2)

# Display the image with bounding boxes
plt.figure(figsize=(6, 6))
plt.imshow(img_array[0])
plt.title('Image with Bounding Box')
plt.axis('off')

plt.show()

"""**How to perform Pixel-wise Comparison with a Random Image from the Same Class?**"""

import os
import random
from skimage import io
import numpy as np
import matplotlib.pyplot as plt

# Define the path to the Cassava Leaf Disease dataset
dataset_path = "/kaggle/input/cassava-leaf-disease-classification/data"

# Choose a random class
random_class = random.choice(os.listdir(dataset_path))
class_path = os.path.join(dataset_path, random_class)

# Get another random image from the same class
random_image_same_class = random.choice(os.listdir(class_path))
image_path_same_class = os.path.join(class_path, random_image_same_class)

# Load the original random image
image = io.imread(image_path_same_class)

# Display the original random image
plt.imshow(image)
plt.title(f'Original Image - {random_class}')
plt.axis('off')
plt.show()

# Load the second random image from the same class
image_same_class = io.imread(image_path_same_class)

# Display the second random image
plt.imshow(image_same_class)
plt.title(f'Second Image - {random_class}')
plt.axis('off')
plt.show()

# Perform Pixel-wise Comparison
pixel_difference = np.abs(image - image_same_class)

# Display the Pixel-wise Comparison
plt.imshow(pixel_difference)
plt.title('Pixel-wise Comparison')
plt.axis('off')
plt.show()

"""**How to Perform Color Analysis using Histogram on a sample image of Cassava Green Mottle?**"""

# Select an image of Cassava Green Mottle
green_mottle_path = os.path.join(dataset_path, 'Cassava___green_mottle')
sample_image_path = os.path.join(green_mottle_path, os.listdir(green_mottle_path)[0])

# Load the sample image
sample_image = io.imread(sample_image_path)

# Display the original image
plt.imshow(sample_image)
plt.title('Cassava Green Mottle - Sample Image')
plt.axis('off')
plt.show()

# Perform Color Analysis using Histogram
hist, bins = np.histogram(sample_image.flatten(), bins=256, range=[0, 256])

# Display the Color Histogram
plt.plot(hist, color='gray')
plt.title('Color Histogram')
plt.xlabel('Pixel Intensity')
plt.ylabel('Frequency')
plt.show()

"""**How to Perform Pixel-wise Comparison on a sample image of Healthy Cassava?**"""

# Select an image of Healthy Cassava
healthy_path = os.path.join(dataset_path, 'Cassava___healthy')
sample_image_path = os.path.join(healthy_path, os.listdir(healthy_path)[0])

# Load the sample image
sample_image_healthy = io.imread(sample_image_path)

# Display the original image
plt.imshow(sample_image_healthy)
plt.title('Healthy Cassava - Sample Image')
plt.axis('off')
plt.show()

# Perform Pixel-wise Comparison
pixel_difference = np.abs(sample_image - sample_image_healthy)

# Display the Pixel-wise Comparison
plt.imshow(pixel_difference)
plt.title('Pixel-wise Comparison')
plt.axis('off')
plt.show()

"""**How does the average lightness vary across different disease classes? (Simplified)**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io, color
from matplotlib.colors import ListedColormap

# Calculate the average lightness for a subset of images in the dataset
num_images_per_class = 50
average_lightness = []

# Define a colormap with a unique color for each class
num_classes = len(os.listdir(dataset_path))
cmap = plt.get_cmap('tab10', num_classes)

for class_idx, class_name in enumerate(os.listdir(dataset_path)):
    class_path = os.path.join(dataset_path, class_name)
    class_images = [io.imread(os.path.join(class_path, img_name)) for img_name in os.listdir(class_path)[:num_images_per_class]]
    avg_lightness = np.mean([np.mean(color.rgb2gray(img)) for img in class_images])
    average_lightness.append((class_name, avg_lightness, cmap(class_idx)))

# Plot the distribution of average lightness
plt.figure(figsize=(12, 6))
for class_name, avg_lightness, color_val in average_lightness:
    plt.scatter(class_name, avg_lightness, label=class_name, color=color_val, alpha=0.7)

plt.title('Average Lightness Across Disease Classes (Subset)')
plt.xlabel('Disease Classes')
plt.ylabel('Average Lightness')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""**How does the overall brightness vary across different disease classes? (Simplified)**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io
from matplotlib.colors import ListedColormap


# Calculate the overall brightness for a subset of images in the dataset
num_images_per_class = 50
overall_brightness = []

# Define a colormap with a unique color for each class
num_classes = len(os.listdir(dataset_path))
cmap = plt.get_cmap('tab10', num_classes)

for class_idx, class_name in enumerate(os.listdir(dataset_path)):
    class_path = os.path.join(dataset_path, class_name)
    class_images = [io.imread(os.path.join(class_path, img_name)) for img_name in os.listdir(class_path)[:num_images_per_class]]
    brightness = np.mean([np.mean(img) for img in class_images])
    overall_brightness.append((class_name, brightness, cmap(class_idx)))

# Plot the distribution of overall brightness
plt.figure(figsize=(12, 6))
for class_name, brightness, color_val in overall_brightness:
    plt.scatter(class_name, brightness, label=class_name, color=color_val, alpha=0.7)

plt.title('Overall Brightness Across Disease Classes (Subset)')
plt.xlabel('Disease Classes')
plt.ylabel('Overall Brightness')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""**How does the contrast vary across different disease classes? (Simplified)**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io, color
from matplotlib.colors import ListedColormap

# Calculate the average contrast for a subset of images in the dataset
num_images_per_class = 50
average_contrast = []

# Define a colormap with a unique color for each class
num_classes = len(os.listdir(dataset_path))
cmap = plt.get_cmap('tab10', num_classes)

for class_idx, class_name in enumerate(os.listdir(dataset_path)):
    class_path = os.path.join(dataset_path, class_name)
    class_images = [io.imread(os.path.join(class_path, img_name)) for img_name in os.listdir(class_path)[:num_images_per_class]]
    avg_contrast = np.mean([np.std(color.rgb2gray(img)) for img in class_images])
    average_contrast.append((class_name, avg_contrast, cmap(class_idx)))

# Plot the distribution of average contrast
plt.figure(figsize=(12, 6))
for class_name, avg_contrast, color_val in average_contrast:
    plt.scatter(class_name, avg_contrast, label=class_name, color=color_val, alpha=0.7)

plt.title('Average Contrast Across Disease Classes (Subset)')
plt.xlabel('Disease Classes')
plt.ylabel('Average Contrast')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""**How does the saturation vary across different disease classes? (Simplified)**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io, color
from matplotlib.colors import ListedColormap

# Calculate the average saturation for a subset of images in the dataset
num_images_per_class = 50
average_saturation = []

# Define a colormap with a unique color for each class
num_classes = len(os.listdir(dataset_path))
cmap = plt.get_cmap('tab10', num_classes)

for class_idx, class_name in enumerate(os.listdir(dataset_path)):
    class_path = os.path.join(dataset_path, class_name)
    class_images = [io.imread(os.path.join(class_path, img_name)) for img_name in os.listdir(class_path)[:num_images_per_class]]
    avg_saturation = np.mean([np.mean(color.rgb2hsv(img)[:, :, 1]) for img in class_images])
    average_saturation.append((class_name, avg_saturation, cmap(class_idx)))

# Plot the distribution of average saturation
plt.figure(figsize=(12, 6))
for class_name, avg_saturation, color_val in average_saturation:
    plt.scatter(class_name, avg_saturation, label=class_name, color=color_val, alpha=0.7)

plt.title('Average Saturation Across Disease Classes (Subset)')
plt.xlabel('Disease Classes')
plt.ylabel('Average Saturation')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""**How does the average hue vary across different disease classes? (Simplified)**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io, color
from matplotlib.colors import ListedColormap

# Calculate the average hue for a subset of images in the dataset
num_images_per_class = 50
average_hue = []

# Define a colormap with a unique color for each class
num_classes = len(os.listdir(dataset_path))
cmap = plt.get_cmap('tab10', num_classes)

for class_idx, class_name in enumerate(os.listdir(dataset_path)):
    class_path = os.path.join(dataset_path, class_name)
    class_images = [io.imread(os.path.join(class_path, img_name)) for img_name in os.listdir(class_path)[:num_images_per_class]]
    avg_hue = np.mean([np.mean(color.rgb2hsv(img)[:, :, 0]) for img in class_images])
    average_hue.append((class_name, avg_hue, cmap(class_idx)))

# Plot the distribution of average hue
plt.figure(figsize=(12, 6))
for class_name, avg_hue, color_val in average_hue:
    plt.scatter(class_name, avg_hue, label=class_name, color=color_val, alpha=0.7)

plt.title('Average Hue Across Disease Classes (Subset)')
plt.xlabel('Disease Classes')
plt.ylabel('Average Hue')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""**Are there certain visual patterns that are more prevalent in images of diseased cassava leaves?**"""

import os
import numpy as np
import matplotlib.pyplot as plt
from skimage import io

# Randomly select a few images of diseased cassava leaves
diseased_class = "Cassava___mosaic_disease"  # Replace with the specific disease class
class_path = os.path.join(dataset_path, diseased_class)
selected_images = np.random.choice(os.listdir(class_path), size=5, replace=False)

# Display the selected images
plt.figure(figsize=(15, 5))
for i, img_name in enumerate(selected_images):
    img = io.imread(os.path.join(class_path, img_name))
    plt.subplot(1, 5, i + 1)
    plt.imshow(img)
    plt.title(f'Image {i + 1}')
    plt.axis('off')

plt.suptitle(f'Selected Images of {diseased_class}')
plt.show()